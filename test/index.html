<!-- <!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Live Captions</title>
  <style>
    body {
      margin: 0;
      padding: 16px 18px;
      font-family: system-ui, Arial, sans-serif;
      background: #0b0b0b;
      color: white;
    }

    #caption {
      font-size: 18px;
      line-height: 1.55;
      font-weight: 500;
      white-space: normal;
      /* paragraph flow */
      word-break: break-word;
    }

    .hint {
      margin-top: 10px;
      opacity: 0.7;
      font-size: 12px;
    }
  </style>

</head>

<body>
  <div id="box">
    <div id="caption">Waiting for speech‚Ä¶</div>
    <div class="hint">Toggle: Ctrl + Shift + H</div>
  </div>


  <script>
    const captionEl = document.getElementById("caption");
    const MAX_CHARS = 900;

    window.captions.onCaption((text) => {
      const t = (text || "").trim();
      if (!t) return;

      const current = captionEl.textContent === "Waiting for speech‚Ä¶" ? "" : (captionEl.textContent || "");
      let next = current ? (current + " " + t) : t;

      if (next.length > MAX_CHARS) next = next.slice(next.length - MAX_CHARS);
      captionEl.textContent = next;
    });
  </script>

</body>

</html> -->


<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Live Captions + Q/A</title>
  <style>
    body {
      margin: 0;
      padding: 16px 18px;
      font-family: system-ui, Arial, sans-serif;
      background: #0b0b0b;
      color: white;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    button {
      /* cursor: pointer; */
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.06);
      color: white;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
    }

    button:disabled {
      opacity: 0.5;
    }

    .pill {
      font-size: 12px;
      opacity: 0.8;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    .draftBox {
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      padding: 10px 12px;
      margin-bottom: 12px;
      background: rgba(255, 255, 255, 0.03);
    }

    .label {
      font-size: 12px;
      opacity: 0.75;
      margin-bottom: 6px;
    }

    .draftText {
      font-size: 14px;
      line-height: 1.5;
      white-space: normal;
      word-break: break-word;
    }

    .qa {
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 16px;
      padding: 12px 12px;
      background: rgba(255, 255, 255, 0.02);
      margin-bottom: 12px;
    }

    .q {
      font-size: 14px;
      line-height: 1.55;
      font-weight: 700;
      margin-bottom: 8px;
    }

    .a {
      font-size: 14px;
      line-height: 1.55;
      opacity: 0.95;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .hint {
      margin-top: 10px;
      opacity: 0.7;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <div class="row">
    <button id="askBtn">Ask</button>
    <button id="askNextBtn">Ask Next</button>
    <div class="pill" id="statusPill">Status: idle</div>
    <div class="pill">Toggle: Ctrl + Shift + H</div>
  </div>

  <div class="row">
    <button id="addShotBtn">Add Screenshot</button>
    <button id="clearShotsBtn">Clear Shots</button>
    <button id="askShotsBtn">Ask w/ Screens</button>
    <div class="pill" id="shotsPill">Shots: 0</div>
  </div>

  <div class="draftBox">
    <div class="label">Screenshots</div>
    <div class="draftText" id="shotsList">‚Äî</div>
  </div>


  <div class="draftBox">
    <div class="label">Current question (draft from captions)</div>
    <div class="draftText" id="currentDraft">Waiting for speech‚Ä¶</div>
  </div>

  <div class="draftBox">
    <div class="label">Next question (captions while streaming)</div>
    <div class="draftText" id="nextDraft">‚Äî</div>
  </div>

  <div id="qaList"></div>

  <script>
    const askBtn = document.getElementById("askBtn");
    const askNextBtn = document.getElementById("askNextBtn");
    const statusPill = document.getElementById("statusPill");

    const currentDraftEl = document.getElementById("currentDraft");
    const nextDraftEl = document.getElementById("nextDraft");
    const qaList = document.getElementById("qaList");

    const MAX_CHARS = 1200;

    let questionCount = 0;

    // Buffers
    let currentDraft = "";
    let nextDraft = "";

    // Streaming state
    let streaming = false;

    // Map blockId -> answer element
    const answerEls = new Map();



    const addShotBtn = document.getElementById("addShotBtn");
    const clearShotsBtn = document.getElementById("clearShotsBtn");
    const askShotsBtn = document.getElementById("askShotsBtn");
    const shotsPill = document.getElementById("shotsPill");
    const shotsList = document.getElementById("shotsList");

    // Store screenshots as data URLs: "data:image/png;base64,..."
    const shots = [];

    function renderShots() {
      console.log("inside render")
      shotsPill.textContent = `Shots: ${shots.length}`;
      shotsList.textContent = shots.length
        ? shots.map((_, i) => `Screenshot ${i + 1}`).join(" ‚Ä¢ ")
        : "‚Äî";

      // enable ask only if we have at least 1 shot and not currently streaming
      askShotsBtn.disabled = streaming || shots.length === 0;
      addShotBtn.disabled = streaming;
      clearShotsBtn.disabled = streaming || shots.length === 0;
    }

    // async function pickAndCaptureOne() {
    //   // Ask main for available sources (screens + windows)
    //   const sources = await window.screenCap.getSources();

    //   // simplest UX: pick the first screen; you can build a small picker UI later
    //   // Better: show a modal list and let user choose.
    //   const preferred =
    //     sources.find(s => s.kind === "screen") ||
    //     sources.find(s => s.kind === "window") ||
    //     sources[0];

    //   if (!preferred) throw new Error("No capture sources found");

    //   // Capture one frame from the chosen source
    //   // const dataUrl = await window.screenCap.captureFrame(preferred.id);
    //   const res = await window.screenCap.captureFrame(preferred.id);
    //   if (!res?.ok) throw new Error(res?.error || "capture failed");
    //   return dataUrl;
    // }

    async function pickAndCaptureOne() {
      const sources = await window.screenCap.getSources();

      const preferred =
        sources.find((s) => s.kind === "screen") ||
        sources.find((s) => s.kind === "window") ||
        sources[0];

      if (!preferred) throw new Error("No capture sources found");

      const res = await window.screenCap.captureFrame(preferred.id);
      if (!res?.ok) throw new Error(res?.error || "capture failed");

      return res.dataUrl; // ‚úÖ correct
    }

    addShotBtn.addEventListener("click", async () => {
      try {
        setStatus("capturing‚Ä¶");
        console.log("insiding event")
        const img = await pickAndCaptureOne();
        console.log("after image")
        shots.push(img);
        console.log("push image")
        setStatus("idle");
        renderShots();
        console.log("after render")
      } catch (e) {
        // console.log("error ", e)
        setStatus("error ");
        console.error(e);
      }
    });

    clearShotsBtn.addEventListener("click", () => {
      shots.length = 0;
      renderShots();
    });

    askShotsBtn.addEventListener("click", async () => {
      if (streaming || shots.length === 0) return;

      // Use currentDraft if you want to add extra text context, else a fixed instruction
      const text = (currentDraft || "").trim();

      const questionText =
        text ||
        "Use the screenshots to solve the coding task. Return working code and a short flow explanation.";

      const { blockId } = createQABlock(`[Screenshots] ${questionText}`);

      streaming = true;
      setStatus("streaming‚Ä¶");
      setButtons();
      renderShots();

      const res = await window.llm.askWithImages({
        blockId,
        question: questionText,
        images: shots, // array of data URLs
      });

      if (!res?.ok) {
        streaming = false;
        setStatus("error");
        setButtons();
        renderShots();
        const aEl = answerEls.get(blockId);
        if (aEl) aEl.textContent = `Answer: [ERROR] ${res?.error || "unknown error"}`;
      }
    });

    function setStatus(s) {
      statusPill.textContent = `Status: ${s}`;
    }

    function clamp(s) {
      s = (s || "").trim();
      if (s.length <= MAX_CHARS) return s;
      return s.slice(s.length - MAX_CHARS);
    }

    function renderDrafts() {
      currentDraftEl.textContent = currentDraft ? currentDraft : "Waiting for speech‚Ä¶";
      nextDraftEl.textContent = nextDraft ? nextDraft : "‚Äî";
    }

    function appendToDraft(which, text) {
      const t = (text || "").trim();
      if (!t) return;

      if (which === "current") {
        currentDraft = clamp(currentDraft ? currentDraft + " " + t : t);
      } else {
        nextDraft = clamp(nextDraft ? nextDraft + " " + t : t);
      }

      renderDrafts();
      setButtons(); // ‚úÖ enable/disable buttons whenever draft changes
    }


    function clearAllDrafts({ clearQA = false } = {}) {
      currentDraft = "";
      nextDraft = "";

      renderDrafts();
      setStatus("idle");
      setButtons();

      if (clearQA) {
        qaList.innerHTML = "";
        answerEls.clear();
        questionCount = 0;
      }
    }


    // Captions come in continuously.
    // If we are currently streaming an answer, new captions go to "nextDraft".
    window.captions.onCaption((text) => {
      appendToDraft(streaming ? "next" : "current", text);
    });

    function createQABlock(questionText) {
      questionCount += 1;
      const blockId = `q_${Date.now()}_${Math.random().toString(16).slice(2)}`;

      const wrap = document.createElement("div");
      wrap.className = "qa";

      const q = document.createElement("div");
      q.className = "q";
      q.textContent = `Question ${questionCount}: ${questionText}`;

      const a = document.createElement("div");
      a.className = "a";
      a.textContent = "Answer: ";

      wrap.appendChild(q);
      wrap.appendChild(a);
      qaList.prepend(wrap);

      answerEls.set(blockId, a);
      return { blockId, answerEl: a };
    }

    function setButtons() {
      askBtn.disabled = streaming || !currentDraft.trim();
      askNextBtn.disabled = streaming || !nextDraft.trim();
    }

    async function askWithText(questionText, consumeWhich) {
      const { blockId } = createQABlock(questionText);

      streaming = true;
      setStatus("streaming‚Ä¶");
      setButtons();

      // Clear the consumed buffer immediately so new captions can accumulate
      if (consumeWhich === "current") currentDraft = "";
      if (consumeWhich === "next") nextDraft = "";
      renderDrafts();

      const res = window.llm.ask({ blockId, question: questionText, mode: consumeWhich });
      if (!res?.ok) {
        streaming = false;
        setStatus("error");
        setButtons();
        const aEl = answerEls.get(blockId);
        if (aEl) aEl.textContent = `Answer: [ERROR] ${res?.error || "unknown error"}`;
      }
    }

    askBtn.addEventListener("click", async () => {
      const q = currentDraft.trim();
      if (!q || streaming) return;
      await askWithText(q, "current");
    });

    askNextBtn.addEventListener("click", async () => {
      const q = nextDraft.trim();
      if (!q || streaming) return;

      // When user clicks Ask Next, it becomes the next official question,
      // and we continue collecting new captions into currentDraft afterwards.
      await askWithText(q, "next");
    });

    // Receive streaming token deltas from main
    window.llm.onDelta(({ blockId, delta }) => {
      const el = answerEls.get(blockId);
      if (!el) return;

      // Keep "Answer: " prefix, append tokens
      if (el.textContent === "Answer: ") {
        el.textContent = "Answer: " + delta;
      } else {
        el.textContent += delta;
      }
    });

    window.llm.onDone(({ blockId, answer }) => {
      const el = answerEls.get(blockId);
      if (el) el.textContent = `Answer: ${answer || ""}`;

      streaming = false;
      setStatus("idle");
      setButtons();

      // After finishing, we want to start drafting the next question from captions.
      // If there is already text in nextDraft (captions happened during streaming),
      // keep it as-is so user can click "Ask Next".
      renderDrafts();
    });

    window.llm.onError(({ blockId, message }) => {
      const el = answerEls.get(blockId);
      if (el) el.textContent = `Answer: [ERROR] ${message || "unknown error"}`;

      streaming = false;
      setStatus("error");
      setButtons();
    });


    // ---- Keyboard shortcuts ----
    // Enter  -> Ask (currentDraft) if available, else Ask Next (nextDraft) if available
    // Shift+Enter -> Ask Next (if available)
    // Esc -> (optional) cancel current stream if you implement llm:cancel wiring

    window.addEventListener("keydown", async (e) => {
      // avoid interfering with typing in inputs/textareas (if you add them later)
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
      if (tag === "input" || tag === "textarea") return;

      // If you want Enter to work even when button is focused, prevent default click/submit behavior
      const isEnter = (e.key === "Enter" || e.code === "Enter" || e.code === "NumpadEnter");
      if (!isEnter && e.key !== "Escape") return;

      // Enter / Shift+Enter
      if (isEnter) {
        e.preventDefault();

        if (streaming) return;

        // Shift+Enter => Ask Next
        if (e.shiftKey) {
          const qNext = nextDraft.trim();
          if (!qNext) return;
          await askWithText(qNext, "next");
          return;
        }

        // Plain Enter => Ask current if possible, else Ask Next
        const qCur = currentDraft.trim();
        if (qCur) {
          await askWithText(qCur, "current");
          return;
        }

        const qNext = nextDraft.trim();
        if (qNext) {
          await askWithText(qNext, "next");
          return;
        }
      }

      // Optional: Escape => cancel
      if (e.key === "Escape") {
        // If you want cancel, you need to store the "active" blockId in renderer
        // and expose window.llm.cancel in preload.
        // For now, do nothing.
      }
    });

    window.addEventListener("keydown", (e) => {
      const tag = (e.target && e.target.tagName || "").toLowerCase();
      if (tag === "input" || tag === "textarea") return;

      // Ctrl + Shift + C => clear captions
      if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === "c") {
        e.preventDefault();

        if (streaming) return; // safety: don't clear mid-stream

        clearAllDrafts({
          clearQA: false, // üîÅ change to true if you want to wipe Q/A history too
        });
      }
    });


    // init
    renderDrafts();
    setButtons();
    setStatus("idle");
    renderShots();
  </script>

  <div class="hint">
    Tip: While an answer is streaming, any new captions automatically go into ‚ÄúNext question‚Äù.
  </div>
</body>

</html>